---
layout: exercises
title:  "Chapter 11: Solutions"
---

## Chapter 11 - Interfaces

### Exercise 2: Type Assertions

Here are updated `Fan` and `CoffeePot` types, both of which satisfy an `Appliance` interface. We've also added a `Use` method that accepts an `Appliance`. Currently, `Use` only calls the `TurnOn` method on the `Appliance`...

Update `Use` so that it calls `Oscillate` on the `Appliance` if (and only if) it's a `Fan`. `Use` should also call `Brew` on the `Appliance` if (and only if) it's a `CoffeePot`.

### Solution

{% highlight go %}
package main

import "fmt"

type Appliance interface {
	TurnOn()
}

type Fan string

func (f Fan) TurnOn() {
	fmt.Println("Spinning")
}
func (f Fan) Oscillate() {
	fmt.Println("Rotating on base")
}

type CoffeePot string

func (c CoffeePot) TurnOn() {
	fmt.Println("Powering up")
}
func (c CoffeePot) Brew() {
	fmt.Println("Heating Up")
}

func Use(appliance Appliance) {
	fmt.Println(appliance)
	appliance.TurnOn()
	// YOUR CODE HERE: If the appliance is a
	// Fan, call its Oscillate method.
	fan, ok := appliance.(Fan)
	if ok {
		fan.Oscillate()
	}
	// If the appliance is a CoffeePot, call
	// its Brew method.
	coffeePot, ok := appliance.(CoffeePot)
	if ok {
		coffeePot.Brew()
	}
}

func main() {
	Use(Fan("Windco Breeze"))
	Use(CoffeePot("LuxBrew"))
}
{% endhighlight %}

Output:

``` text
Windco Breeze
Spinning
Rotating on base
LuxBrew
Powering up
Heating Up
```
